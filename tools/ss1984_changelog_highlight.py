# vibecoding is real, at least ~50% this code generated by AI

import subprocess
import json
import os
import re
import warnings
from pathlib import Path
from datetime import datetime
from collections import defaultdict
from collections import deque

# Folder containing the changelog YAML files
CHANGELOG_ALL_FOLDER = 'html/changelogs/'
OUTPUT_JSON_PATH = 'ss1984_changelog_highlight_generated.json'
BOT_AUTHOR = '1984-ci-event'  # For future commit filtering if needed
BOT_AUTHOR_FULLNAME = '1984-ci-event[bot]'

BASE_DIR = Path(__file__).resolve().parent  # Directory where your script lives
GIT_REPO_PATH = BASE_DIR.parent  # This is platform-independent Path object
git_repo_path_str = str(GIT_REPO_PATH)

SKIP_BELOW_YEAR = 2025
SKIP_PR_PARTIAL_BEFORE_DATE = "2025-06-05" # did not correctly setup changelogs before that data
BOT_COMMIT_MSG = "Automatic changelog compile [ci skip]"
AUTOCHANGELOG_REGEX = re.compile(r"AutoChangeLog-pr-(\d+)\.ya?ml$")
AUTHOR_REGEX = re.compile(r'^-author:\s*"([^"]+)"')
CHANGES_START_LINE = "-changes:"
REGEX_PARTIAL_MATCHES = re.compile(r'(\w+):\x1E(.*?)(?=(?:\w+:\x1E)|$)')
AUTOCHANGELOG_REGEX_NEW = re.compile(r'^--- a/(?!archive/)(.+)')
CUTOFF_STR = "-  - "
INDENT_AMOUNT = 2

def remove_changes_after_and_date(file_insertions_old, last_commit_date_str):
    # Convert last_commit_date from string to datetime for comparisons
    last_commit_date = datetime.strptime(last_commit_date_str, "%Y-%m-%d")

    temp_deque = deque(file_insertions_old)

    while temp_deque:
        # Peek at the date of the leftmost entry
        entry_date_str = temp_deque[0]['date']
        entry_date = datetime.strptime(entry_date_str, "%Y-%m-%d")

        # Once date is below last_commit_date, stop removing
        if entry_date < last_commit_date:
            break
        else:
            temp_deque.popleft()

    return list(temp_deque)

def normalize_change(change):
    change = re.sub(r'^\s*-\s*', '', change)
    change = re.sub(r'^(?:\S+?:\s*)', '', change)
    change = normalize_whitespace(change)
    if len(change) > 0 and change[0] == '\"':
        change = change[1:]
    change_len = len(change)
    if change_len > 1 and change[-1] == '\"':
        change = change[:-1]
    return change

def normalize_whitespace(line):
    # 1. Separate leading whitespace from actual content
    leading_ws_match = re.match(r'^(\s*)(.*)$', line)
    if not leading_ws_match:
        return line.strip()
    leading_ws = leading_ws_match.group(1)
    content = leading_ws_match.group(2)

    # 2. Collapse internal whitespace in content only (replace multiple spaces/tabs/newlines with a single space)
    content = re.sub(r'\s+', ' ', content)

    # 3. Remove trailing spaces (already effectively done by collapsing, but be explicit)
    content = content.rstrip()

    # 4. Recombine
    return leading_ws + content

def is_garbled_latin1(text):
    return any(128 <= ord(ch) <= 255 for ch in text)

def fix_misdecoded_utf8(text):
    return text.encode('latin1').decode('utf-8')

def process_data(autoChangelog_files_prev, file_insertions, prev_date):
    autochangelog_full = '\x1E'.join(autoChangelog_files_prev).strip()
    if not autochangelog_full:
        return
    all_matches = REGEX_PARTIAL_MATCHES.findall(autochangelog_full)
    was_present_authors = defaultdict(list)
    for _, (author, changes_full) in enumerate(all_matches, 1):
        was_present_authors[author].append(changes_full)
    for author_present in was_present_authors:
        changes_group_per_author = was_present_authors[author_present]
        for change_chunk in changes_group_per_author:
            str_changes: str = change_chunk
            # Cyrillic case
            # Imagine we receive as changes: Ñ\x82ÐµÑ\x81Ñ\x82Ñ\x8b Ð´Ð»Ñ\x8f ÐºÐ¾Ð´Ð°
            # When initially was readed (per lines) as: \u0442\u0435\u0441\u0442\u044B \u0434\u043B\u044F \u043A\u043E\u0434\u0430
            if is_garbled_latin1(str_changes):
                str_changes = fix_misdecoded_utf8(str_changes)
                if str_changes.endswith('\\x1e') or str_changes.endswith('\\x1E'): # encoding hellfest
                    str_changes = str_changes[:-4] # 1 -> 4 byte UTF8 moment
            changes = str_changes.splitlines()
            file_insertions.append({
                'date': prev_date,
                'author': author_present,
                'changes': changes
            })

def get_bot_commit_diffs(last_commit_date, file_insertions_old):
    # Get bot commit hashes touching the changelog folder

    last_commit_date_str = SKIP_BELOW_YEAR
    if last_commit_date:
        last_commit_date_str = last_commit_date

    cmd_hashes = [
        'git', '-C', git_repo_path_str, 'log',
        '--author=' + BOT_AUTHOR,
        '--since=' + last_commit_date_str,
        '--pretty=format:%H',
        '--', CHANGELOG_ALL_FOLDER
    ]
    commit_hashes = subprocess.check_output(cmd_hashes, text=True).splitlines()

    file_insertions = list()
    last_date = None
    prev_date = None

    autoChangelog_files = list()
    autoChangelog_files_prev = list()
    skip_file = True
    is_changes = False
    last_author = None
    was_different_data = False


    for commit_hash in commit_hashes:
        cmd_date = ['git', '-C', git_repo_path_str, 'show', '-s', '--format=%cI', commit_hash]
        commit_date_str = subprocess.check_output(cmd_date, text=True).strip()
        commit_date = datetime.fromisoformat(commit_date_str)

        cmd_msg = ['git', 'log', "--format=%B", '-n 1', commit_hash]
        commit_msg = subprocess.check_output(cmd_msg, text=True).strip()

        if (commit_msg != BOT_COMMIT_MSG):
            continue

        cmd_diff = ['git', "-c", "core.quotepath=false", "-c", "i18n.logoutputencoding=utf-8", '-C', git_repo_path_str, 'show', '-U0', '--format=', "--diff-filter=D", commit_hash, '--', CHANGELOG_ALL_FOLDER]
        diff_text = subprocess.check_output(cmd_diff, text=True, encoding='utf-8')
        diff_text_fixed = None
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", DeprecationWarning)
            diff_text_fixed = diff_text.encode('utf-8').decode('unicode_escape')
        formatted_date = commit_date.strftime('%Y-%m-%d')

        if last_date != formatted_date:
            autoChangelog_files_prev = autoChangelog_files
            prev_date = last_date
            autoChangelog_files = list()
            skip_file = True
            is_changes = False
            last_author = None
            was_different_data = True
            last_date = formatted_date
        else:
            was_different_data = False

        for line in diff_text_fixed.splitlines():
            is_autochangelog_match = AUTOCHANGELOG_REGEX_NEW.match(line)
            if is_autochangelog_match:
                fname_match = is_autochangelog_match.group(1)
                if fname_match:
                    was_touched_by_bot_cmd = ["git", "log", "-1", "--diff-filter=A", "--format=%an", "--since=" + last_commit_date_str, "--", fname_match]
                    was_touched_by_bots = subprocess.check_output(was_touched_by_bot_cmd, text=True).strip()
                    is_our_changelog = False
                    if not was_touched_by_bots: # fallback
                        cmd_author = ['git', 'log', "--diff-filter=A", '-1', '--format=%an', commit_hash]
                        author_name = subprocess.check_output(cmd_author, text=True).strip()
                        was_touched_by_bots = author_name
                    if was_touched_by_bots:
                        was_touched_arr = was_touched_by_bots.splitlines()
                        is_our_changelog = BOT_AUTHOR_FULLNAME in was_touched_arr
                    if is_our_changelog:
                        skip_file = False
                        is_changes = False
                    else:
                        skip_file = True
                else:
                    skip_file = True
                continue

            if (skip_file):
                continue

            if not line.startswith('-'): # some invalid or git stuff things like delete node...
                continue

            m_author = AUTHOR_REGEX.search(line)
            if (m_author):
                author = m_author.group(1)
                if author != last_author:
                    author_text = author + ":"
                    autoChangelog_files.append(author_text) # don't really care about order of insertions
                last_author = author
                is_changes = False
                continue

            if is_changes:
                if not line.startswith(CUTOFF_STR):
                    is_changes = False
                    continue
                cleaned_line = line[1:]
                cleaned_line = normalize_change(cleaned_line)
                autoChangelog_files.append(cleaned_line)

            if (line == CHANGES_START_LINE):
                is_changes = True
                continue


        if not was_different_data:
            continue
        if len(autoChangelog_files_prev) < 1: # we at beginning
            continue
        process_data(autoChangelog_files_prev, file_insertions, prev_date)

    if len(autoChangelog_files) > 0:
        process_data(autoChangelog_files, file_insertions, last_date)

    if file_insertions_old:
        cleaned_old = remove_changes_after_and_date(file_insertions_old, last_commit_date_str)
        if cleaned_old:
            file_insertions = file_insertions + cleaned_old

    return file_insertions

def try_find_last_commit_date(output_path_actual):
    if not os.path.exists(output_path_actual):
        return None, None
    # Load the JSON data from file
    file_insertions = None
    with open(output_path_actual, 'r', encoding='utf-8') as file:
        file_insertions = json.load(file)
    if file_insertions:
        top_insert = file_insertions[0]
        if top_insert:
            top_insert_date = top_insert ["date"]
            if (top_insert_date):
                return (top_insert_date, file_insertions)
    print("WARNING: Failed to retrieve last changelog date from existing file " + output_path_actual + ", will regenerate file")
    return None, None

def main():
    output_path_actual = os.path.join((str(BASE_DIR)), OUTPUT_JSON_PATH)
    (last_commit_date, file_insertions_old) = try_find_last_commit_date(output_path_actual)
    file_insertions = get_bot_commit_diffs(last_commit_date, file_insertions_old)
    with open(output_path_actual, 'w', encoding='utf-8') as f:
        json.dump(file_insertions, f, indent=INDENT_AMOUNT, ensure_ascii=False)

    print(f"Saved {len(file_insertions)} entries from bot commits based on diff insertions.")

if __name__ == '__main__':
    main()
