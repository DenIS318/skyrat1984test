# vibecoding is real, almost all of this code generated by AI

import subprocess
import yaml
import json
import os
import re
from collections import defaultdict
from pathlib import Path

# Folder containing the changelog YAML files
CHANGELOG_FOLDER = 'html/changelogs/archive'
OUTPUT_JSON_PATH = 'ss1984_changelog_highlight_generated.json'
BOT_AUTHOR = '1984-ci-event'  # For future commit filtering if needed

BASE_DIR = Path(__file__).resolve().parent  # Directory where your script lives
GIT_REPO_PATH = BASE_DIR.parent  # This is platform-independent Path object
git_repo_path_str = str(GIT_REPO_PATH)

SKIP_BELOW_YEAR = 2025
BOT_COMMIT_MSG = "Automatic changelog compile [ci skip]"

def extract_change_text(changes_list):
    texts = []
    for change_dict in changes_list:
        if isinstance(change_dict, dict):
            # Extract all values as strings
            texts.extend(str(v) for v in change_dict.values())
        else:
            texts.append(str(change_dict))
    return texts  # <-- return list directly instead of joining

def get_bot_commit_diffs():
    # Get bot commit hashes touching the changelog folder
    cmd_hashes = [
        'git', '-C', git_repo_path_str, 'log',
        '--author=' + BOT_AUTHOR,
        '--pretty=format:%H',
        '--', CHANGELOG_FOLDER
    ]
    commit_hashes = subprocess.check_output(cmd_hashes, text=True).splitlines()

    file_insertions = defaultdict(list)  # filepath -> list of inserted YAML chunks (per commit)

    for commit_hash in commit_hashes:
        cmd_diff = ['git', '-C', git_repo_path_str, 'show', '-U0', '--format=', commit_hash, '--', CHANGELOG_FOLDER]
        diff_text = subprocess.check_output(cmd_diff, text=True)

        current_file = None
        added_lines = []

        for line in diff_text.splitlines():
            # Detect file diff start
            m = re.match(r'^diff --git a/(.+) b/(.+)$', line)
            if m:
                if current_file and added_lines:
                    # Save previous file insertions
                    file_insertions[current_file].append('\n'.join(added_lines))
                    added_lines = []
                current_file = m.group(2)  # Use b/ path (new file)
                continue

            # If line is insertion in diff: starts with '+', but not '+++' header line
            if line.startswith('+') and not line.startswith('+++'):
                added_lines.append(line[1:])  # strip '+'
            elif line.startswith('-') or line.startswith(' '):
                # Context or removal resets insertion buffer to avoid mixing diffs
                if added_lines:
                    file_insertions[current_file].append('\n'.join(added_lines))
                    added_lines = []

        # At end of diff, save any pending inserted lines
        if current_file and added_lines:
            file_insertions[current_file].append('\n'.join(added_lines))

    return file_insertions

def parse_full_changelogs(folder):
    folder_path = Path(folder).resolve()
    full_changelogs = {}
    for root, dirs, files in os.walk(folder):
        for file in files:
            if not file.endswith('.yml') and not file.endswith('.yaml'):
                continue
            year_match = re.match(r"(\d{4})-\d{2}\.ya?ml$", file)
            if year_match:
                year = int(year_match.group(1))
                if year < SKIP_BELOW_YEAR:
                    # Skip files older than 2025
                    continue
            path = Path(root) / file
            with open(path, 'r', encoding='utf-8') as f:
                yaml_data = yaml.safe_load(f)
            relative_path = path.resolve().relative_to(folder_path).as_posix()
            full_changelogs[relative_path] = yaml_data
    return full_changelogs

def yaml_entries_from_text(yaml_text):
    try:
        # Parse YAML fragment that contains authors at root level
        return yaml.safe_load(yaml_text)
    except Exception:
        return None

def filter_entries_by_diff_insertions(full_changelogs, file_insertions):
    filtered_entries = []

    full_changelogs_keys = set(full_changelogs.keys())

    for file_path_raw, inserted_chunks in file_insertions.items():
        file_path = Path(file_path_raw).as_posix()   # Convert to posix style for matching

        # Sometimes file_path might have a prefix (like 'html/changelogs/archive/2025-08.yml')
        # If your full_changelogs keys are relative to 'html/changelogs/archive',
        # extract basename or relative part accordingly, e.g.:
        file_path_name = Path(file_path).name  # just '2025-08.yml'

        # Try exact and basename matching
        # First try full path match, else fallback to basename match if unique
        if file_path in full_changelogs_keys:
            key_to_use = file_path
        elif file_path_name in full_changelogs_keys:
            key_to_use = file_path_name
        else:
            # Skip files not found in full changelogs keys
            continue

        full_yaml = full_changelogs[key_to_use]

        for chunk in inserted_chunks:
            inserted_yaml = yaml_entries_from_text(chunk)
            if not inserted_yaml:
                # skip this invalid or empty yaml fragment
                continue
            if not isinstance(inserted_yaml, dict):
                # skip if parsed YAML is not a dictionary, since you expect dict of dates
                continue

            for date, authors_dict in full_yaml.items():
                if not isinstance(authors_dict, dict):
                    continue
                for author, changes_list in authors_dict.items():
                    if date in inserted_yaml and isinstance(inserted_yaml[date], dict) and author in inserted_yaml[date]:
                        inserted_changes = inserted_yaml[date][author]
                        if not isinstance(inserted_changes, list):
                            continue
                        full_changes = changes_list if isinstance(changes_list, list) else []

                        # Modified handling to iterate over all changes
                        match_found = False
                        for ic in inserted_changes:
                            for fc in full_changes:
                                if isinstance(ic, dict) and isinstance(fc, dict):
                                    # Check if any value in inserted change dict matches any value in full change dict
                                    if any(v == val for v in ic.values() for val in fc.values()):
                                        match_found = True
                                        break
                            if match_found:
                                break

                        if match_found:
                            filtered_entries.append({
                                'date': date,
                                'author': author,
                                'changes': extract_change_text(full_changes),
                            })
    return filtered_entries

def serialize_dates(entries):
    for entry in entries:
        if hasattr(entry['date'], 'isoformat'):
            entry['date'] = entry['date'].isoformat()
    return entries

def main():
    file_insertions = get_bot_commit_diffs()
    full_changelogs = parse_full_changelogs(CHANGELOG_FOLDER)
    filtered_entries = filter_entries_by_diff_insertions(full_changelogs, file_insertions)
    output_path_actual = os.path.join((str(BASE_DIR)), OUTPUT_JSON_PATH)

    serialized_entries = serialize_dates(filtered_entries)

    with open(output_path_actual, 'w', encoding='utf-8') as f:
        json.dump(serialized_entries, f, indent=2, ensure_ascii=False)

    print(f"Saved {len(serialized_entries)} entries from bot commits based on diff insertions.")

if __name__ == '__main__':
    main()
