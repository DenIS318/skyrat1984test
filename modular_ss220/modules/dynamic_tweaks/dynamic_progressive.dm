#define PROGRESSIVE_DYNAMIC_TITLE "\[Progressive Dynamic\]"

// If enabled, all these additions will work
GLOBAL_VAR_INIT(dynamic_progressive_enabled, TRUE)

SUBSYSTEM_DEF(progressive_dynamic)
	name = "Progressive Dynamic"
	flags = SS_NO_INIT
	wait = 1 SECONDS // Default wait time before fire() invoked, should be set to increase_interval during setup

	// Coefficients for roles (higher one takes priority, so Head Of Security uses security_coefficient)
	var/security_coefficient = 5.0
	var/head_coefficient = 4.0
	var/crew_coefficient = 1.0

	var/roles_coefficient_multiplier = 2.0 // All coefficients (security_coefficient... etc) multiplied by this
	var/max_generated_threat = 100 // How much threat could be generated by this system before it stops

	var/increase_interval = 1 MINUTES // deciseconds, 600 = 1 minute, zero and negative values will disable timer completly, effective stopping the system from startup
	var/max_increase_time = 70 MINUTES // At this point and after, coefficient for threat = max_increase_coeff
	var/min_increase_coeff = 0.0 // minimum value of coefficient at max_increase_time, which overall_power is multiplied by
	var/max_increase_coeff = 1.0 // maximum value of coefficient at max_increase_time, which overall_power is multiplied by

	var/max_threat_threshold_to_stop = 80 // Will increase midround_budget only up to this value

	// NO CONFIGURATION PAST THIS
	var/generated_threat_by_progressive_dynamic = 0 // How much threat was generated by progressive dynamic
	var/list/configuration = null

/datum/controller/subsystem/progressive_dynamic/proc/do_setup()
	// Load from file
	var/json_file = file("[global.config.directory]/dynamic_progressive.json")
	if(fexists(json_file))
		configuration = json_decode(file2text(json_file))
		if(configuration["Progressive Dynamic"])
			for(var/variable in configuration["Progressive Dynamic"])
				if(!(variable in vars))
					stack_trace("Invalid progressive dynamic configuration variable [variable] in game mode variable changes.")
					continue
				vars[variable] = configuration["Progressive Dynamic"][variable]

	if (increase_interval > 0) // Actual setup goes if that parameter valid
		wait = increase_interval
		return
	GLOB.dynamic_progressive_enabled = FALSE // Incorrect setup, mark as disabled and destroying subsystem
	Destroy()

/datum/controller/subsystem/progressive_dynamic/fire()
	if (!GLOB.dynamic_progressive_enabled || generated_threat_by_progressive_dynamic >= max_generated_threat || !SSdynamic || !SSticker || SSticker.current_state != GAME_STATE_PLAYING)
		return

	var/time_in_deciseconds = STATION_TIME_PASSED()
	var/sec_amount = 0
	var/head_amount = 0
	var/crew_amount = 0

	for(var/mob/checked_mob in GLOB.mob_list)
		if (!checked_mob.ckey || isnewplayer(checked_mob))
			continue
		if(!checked_mob.mind || isbrain(checked_mob) || isobserver(checked_mob))
			continue
		if (checked_mob.stat == DEAD || is_centcom_level(checked_mob.z) || !checked_mob.client)
			continue
		if(checked_mob.mind.special_role) // oh no, obsessed HOS is not contributing to station the same way, as heretic engineer...
			continue
		// HIGHER PRIORITY CHECKS GOES FIRST, SO HEADS AND ETC ARE SKIPPED IF MOB IN SECURITY
		if(checked_mob.mind.assigned_role?.departments_list?.Find(/datum/job_department/security))
			sec_amount++
			continue
		if(checked_mob.mind.assigned_role?.departments_list?.Find(/datum/job_department/central_command))
			head_amount++
			continue
		if(checked_mob.mind.assigned_role?.departments_list?.Find(/datum/job_department/command))
			crew_amount++
			continue

	var/overall_power = calculate_station_power(sec_amount, head_amount, crew_amount)
	var/threat_increase = calculate_threat_increase(time_in_deciseconds, overall_power)
	var/possible_next_threat = threat_increase + SSdynamic.mid_round_budget
	if (possible_next_threat > max_threat_threshold_to_stop)
		threat_increase = max_threat_threshold_to_stop - SSdynamic.mid_round_budget
	else if (possible_next_threat > SSdynamic.max_threat_level)
		threat_increase = SSdynamic.max_threat_level - SSdynamic.mid_round_budget

	var/increase_threat_msg = "[gameTimestamp()]: [PROGRESSIVE_DYNAMIC_TITLE]: automatically increasing threat by [threat_increase] (secs = [sec_amount], heads = [head_amount], crew = [crew_amount])"
	SSdynamic.create_threat(threat_increase, SSdynamic.threat_log, increase_threat_msg)
	generated_threat_by_progressive_dynamic += threat_increase

	log_dynamic(increase_threat_msg)
	update_fire_state()

/datum/controller/subsystem/progressive_dynamic/proc/calculate_station_power(sec_amount, head_amount, crew_amount)
	if (!sec_amount)
		sec_amount = 0
	if (!head_amount)
		head_amount = 0
	if (!crew_amount)
		crew_amount = 0
	var/overall_power = (sec_amount * security_coefficient + head_amount * head_coefficient + crew_amount * crew_coefficient) * roles_coefficient_multiplier / 100
	if (overall_power < 0)
		return 0
	return overall_power

/datum/controller/subsystem/progressive_dynamic/proc/calculate_threat_coefficient(time_in_deciseconds)
	if (!time_in_deciseconds || !max_increase_time) // should be fine to avoid zero division
		return 0
	var/normalized_time = time_in_deciseconds / max_increase_time
	if (normalized_time > max_increase_coeff) // clamping
		normalized_time = max_increase_coeff
	else if (normalized_time < min_increase_coeff)
		normalized_time = min_increase_coeff
	return (min_increase_coeff + max_increase_coeff - min_increase_coeff) * normalized_time // typical lerp

/datum/controller/subsystem/progressive_dynamic/proc/calculate_threat_increase(time_in_deciseconds, overall_power)
	if (!overall_power)
		return 0

	return calculate_threat_coefficient(time_in_deciseconds) * overall_power

/datum/controller/subsystem/progressive_dynamic/proc/get_progressive_admin_panel(list/dat)
	if (!dat)
		return
	if (increase_interval > 0)
		dat += "Progressive Dynamic: <a href='byond://?src=[text_ref(src)];[HrefToken()];progressive_dynamic=1'><b>[GLOB.dynamic_progressive_enabled ? "On" : "Off"]</b></a>"
		dat += "<a href='byond://?_src_=vars;[HrefToken()];Vars=[REF(src)]'>\[VV\]</a><br/>"
	else
		dat += "Progressive Dynamic: <b>DISABLED</b> due to zero or negative increase_interval<br/>" // Check config in that case

/datum/controller/subsystem/progressive_dynamic/Topic(href, href_list)
	. = ..(href, href_list)
	if (.)
		return
	if (href_list["progressive_dynamic"])
		GLOB.dynamic_progressive_enabled = !GLOB.dynamic_progressive_enabled

	SSdynamic?.admin_panel()

/datum/controller/subsystem/progressive_dynamic/vv_edit_var(var_name, var_value)
	. = ..()
	if (!.)
		return FALSE

	if (var_name == "increase_interval")
		if (var_value > 1)
			wait = var_value
			return TRUE
		return FALSE

	if (var_name == "wait")
		increase_interval = var_value
		return TRUE

	if (var_name == "max_generated_threat" || var_name == "generated_threat_by_progressive_dynamic")
		update_fire_state()

/datum/controller/subsystem/progressive_dynamic/proc/update_fire_state()
	if (generated_threat_by_progressive_dynamic < max_generated_threat && !can_fire)
		log_dynamic("[gameTimestamp()]: [PROGRESSIVE_DYNAMIC_TITLE]: Enabling progressive threat updates")
		can_fire = TRUE
	else if (generated_threat_by_progressive_dynamic >= max_generated_threat && can_fire)
		log_dynamic("[gameTimestamp()]: [PROGRESSIVE_DYNAMIC_TITLE]: Disabling progressive threat updates due to generated [generated_threat_by_progressive_dynamic] out of allowed [max_generated_threat]")
		can_fire = FALSE // Temporaly disable fire(), admins still can VV generated_threat_by_progressive_dynamic or max_generated_threat (look at vv_edit_var)

