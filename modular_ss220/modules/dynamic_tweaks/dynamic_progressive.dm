#define PROGRESSIVE_DYNAMIC_TITLE "\[Progressive Dynamic\]"

// If enabled, all these additions will work
GLOBAL_VAR_INIT(dynamic_progressive_enabled, TRUE)

SUBSYSTEM_DEF(progressive_dynamic)
	name = "Progressive Dynamic"
	wait = 1 SECONDS // Default wait time before fire() invoked, should be set to increase_interval during setup

	// Coefficients for roles (higher one takes priority, so Head Of Security uses security_coefficient)
	var/security_coefficient = 5.0
	var/head_coefficient = 4.0
	var/crew_coefficient = 1.0

	var/roles_coefficient_multiplier = 2.0 // All coefficients (security_coefficient... etc) multiplied by this

	var/increase_interval = 1 MINUTES // deciseconds, 600 = 1 minute, zero and negative values will disable timer completly, effective stopping the system from startup
	var/max_increase_time = 70 MINUTES // At this point and after, coefficient for threat = max_increase_coeff
	var/min_increase_coeff = 0.0 // minimum value of coefficient at max_increase_time, which overall_power is multiplied by
	var/max_increase_coeff = 1.0 // maximum value of coefficient at max_increase_time, which overall_power is multiplied by
	var/list/required_threat_to_raise_one_lvl = list()

	var/max_dynamic_tier_to_stop = DYNAMIC_TIER_HIGH // disabled once tier reached
	var/announce_to_station_when_tier_increased = TRUE

	// NO CONFIGURATION PAST THIS
	var/generated_threat_by_progressive_dynamic = 0 // How much threat was generated by progressive dynamic
	var/list/configuration = null

/datum/controller/subsystem/progressive_dynamic/Initialize()
	// Load from file
	var/json_file = file("[global.config.directory]/dynamic_progressive.json")
	if(fexists(json_file))
		configuration = json_decode(file2text(json_file))
		if(configuration["Progressive Dynamic"])
			for(var/variable in configuration["Progressive Dynamic"])
				if(!(variable in vars))
					stack_trace("Invalid progressive dynamic configuration variable [variable] in game mode variable changes.")
					continue
				vars[variable] = configuration["Progressive Dynamic"][variable]

	if (increase_interval > 0) // Actual setup goes if that parameter valid
		wait = increase_interval
		return SS_INIT_SUCCESS
	GLOB.dynamic_progressive_enabled = FALSE // Incorrect setup, mark as disabled and destroying subsystem
	can_fire = FALSE
	return SS_INIT_FAILURE

/datum/controller/subsystem/progressive_dynamic/fire()
	if (!GLOB.dynamic_progressive_enabled || !SSdynamic || !SSticker || SSticker.current_state != GAME_STATE_PLAYING || !SSdynamic.current_tier || SSdynamic.current_tier.tier >= max_dynamic_tier_to_stop)
		return

	var/time_in_deciseconds = world.time
	var/sec_amount = 0
	var/head_amount = 0
	var/crew_amount = 0

	for(var/mob/checked_mob in GLOB.mob_list)
		if (!checked_mob.ckey || isnewplayer(checked_mob))
			continue
		if(!checked_mob.mind || isbrain(checked_mob) || isobserver(checked_mob))
			continue
		if (checked_mob.stat == DEAD || is_centcom_level(checked_mob.z) || !checked_mob.client)
			continue
		if(checked_mob.is_antag())
			continue
		if (isliving(checked_mob))
			var/mob/living/living_mob = checked_mob
			if (living_mob.ssd_indicator)
				continue
		if (ishuman(checked_mob))
			var/mob/living/carbon/human/human_mob = checked_mob
			if (human_mob.has_trauma_type(/datum/brain_trauma/special/obsessed)) // oh no, obsessed HOS is not contributing to station the same way, as heretic engineer...
				continue
		// No not-crew (ghost roles) or unassigned (at mind, not at card) roles
		if (!checked_mob.mind.assigned_role || !(checked_mob.mind.assigned_role.job_flags & JOB_CREW_MEMBER))
			continue
		// HIGHER PRIORITY CHECKS GOES FIRST, SO HEADS AND ETC ARE SKIPPED IF MOB IN SECURITY
		if(checked_mob.mind.assigned_role.departments_list?.Find(/datum/job_department/security))
			sec_amount++
			continue
		if(checked_mob.mind.assigned_role.departments_list?.Find(/datum/job_department/command))
			head_amount++
			continue
		crew_amount++

	var/overall_power = calculate_station_power(sec_amount, head_amount, crew_amount)
	var/threat_increase = calculate_threat_increase(time_in_deciseconds, overall_power)

	generated_threat_by_progressive_dynamic += threat_increase
	log_dynamic("[gameTimestamp()]: [PROGRESSIVE_DYNAMIC_TITLE]: automatically increasing threat by [threat_increase] (secs = [sec_amount], heads = [head_amount], crew = [crew_amount])")
	update_tier()
	update_fire_state()

/datum/controller/subsystem/progressive_dynamic/proc/update_tier()
	if (!SSdynamic || !SSdynamic.current_tier)
		return
	if (!required_threat_to_raise_one_lvl || !islist(required_threat_to_raise_one_lvl))
		log_runtime("required_threat_to_raise_one_lvl is null or not list!")
		return
	if (required_threat_to_raise_one_lvl.len < 1)
		log_runtime("required_threat_to_raise_one_lvl is empty!")
		return
	if (SSdynamic.current_tier.tier >= required_threat_to_raise_one_lvl.len)
		return
	var/required_threat_to_raise_actual = required_threat_to_raise_one_lvl[SSdynamic.current_tier.tier]
	if (generated_threat_by_progressive_dynamic < required_threat_to_raise_actual)
		return
	var/new_tier_num = SSdynamic.current_tier.tier + 1
	var/datum/dynamic_tier/found_new_tier
	for(var/datum/dynamic_tier/tier_datum as anything in subtypesof(/datum/dynamic_tier))
		if(tier_datum.tier == new_tier_num)
			found_new_tier = tier_datum
			break
	if (found_new_tier)
		log_runtime("Failed to find tier with num [new_tier_num]!")
		return

	SSdynamic.set_tier(found_new_tier)
	log_dynamic("[gameTimestamp()]: [PROGRESSIVE_DYNAMIC_TITLE]: automatically increasing DYNAMIC LEVEL, reached [generated_threat_by_progressive_dynamic] of required [required_threat_to_raise_actual] threat")
	if (!announce_to_station_when_tier_increased)
		return
	var/report = "<b><i>Nanotrasen Department of Intelligence Threat Advisory, Spinward Sector, TCD [time2text(world.realtime, "DDD, MMM DD")], [CURRENT_STATION_YEAR]:</i></b><hr>"
	report += "Advisory level was raised for sector due to latest intelligence reports.<hr>"
	report += found_new_tier.advisory_report
	print_command_report(report, "[command_name()] Status Summary", announce=TRUE)

/datum/controller/subsystem/progressive_dynamic/proc/calculate_station_power(sec_amount, head_amount, crew_amount)
	if (!sec_amount)
		sec_amount = 0
	if (!head_amount)
		head_amount = 0
	if (!crew_amount)
		crew_amount = 0
	var/overall_power = (sec_amount * security_coefficient + head_amount * head_coefficient + crew_amount * crew_coefficient) * roles_coefficient_multiplier / 100
	if (overall_power < 0)
		return 0
	return overall_power

/datum/controller/subsystem/progressive_dynamic/proc/calculate_threat_coefficient(time_in_deciseconds)
	if (!time_in_deciseconds || !max_increase_time) // should be fine to avoid zero division
		return 0
	var/normalized_time = time_in_deciseconds / max_increase_time
	if (normalized_time > max_increase_coeff) // clamping
		normalized_time = max_increase_coeff
	else if (normalized_time < min_increase_coeff)
		normalized_time = min_increase_coeff
	return (min_increase_coeff + max_increase_coeff - min_increase_coeff) * normalized_time // typical lerp

/datum/controller/subsystem/progressive_dynamic/proc/calculate_threat_increase(time_in_deciseconds, overall_power)
	if (!overall_power)
		return 0

	return calculate_threat_coefficient(time_in_deciseconds) * overall_power

/datum/controller/subsystem/progressive_dynamic/vv_edit_var(var_name, var_value)
	. = ..()
	if (!.)
		return FALSE

	if (var_name == "increase_interval")
		if (var_value > 1)
			wait = var_value
			return TRUE
		return FALSE

	if (var_name == "wait")
		increase_interval = var_value
		return TRUE

	if (var_name == "required_threat_to_raise_one_lvl")
		update_tier()
		return TRUE

	if (var_name == "max_dynamic_tier_to_stop" || var_name == "generated_threat_by_progressive_dynamic")
		update_fire_state()
		return TRUE

	return FALSE

/datum/controller/subsystem/progressive_dynamic/proc/update_fire_state()
	if (SSdynamic?.current_tier?.tier < max_dynamic_tier_to_stop && !can_fire)
		log_dynamic("[gameTimestamp()]: [PROGRESSIVE_DYNAMIC_TITLE]: Enabling progressive threat updates")
		can_fire = TRUE
	else if (SSdynamic?.current_tier?.tier >= max_dynamic_tier_to_stop && can_fire)
		log_dynamic("[gameTimestamp()]: [PROGRESSIVE_DYNAMIC_TITLE]: Disabling progressive threat updates due to reached tier [SSdynamic.current_tier.tier] out of allowed [max_dynamic_tier_to_stop]")
		can_fire = FALSE // Temporaly disable fire(), admins still can VV generated_threat_by_progressive_dynamic or max_generated_threat (look at vv_edit_var)
